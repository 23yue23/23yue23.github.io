<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蜗牛笔记</title>
  
  <subtitle>骑士的心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://23yue23.github.io/"/>
  <updated>2019-09-25T02:51:01.100Z</updated>
  <id>https://23yue23.github.io/</id>
  
  <author>
    <name>Brady</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flink-实战篇</title>
    <link href="https://23yue23.github.io/2019/09/25/flink-%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/09/25/flink-实战篇/</id>
    <published>2019-09-25T02:51:01.000Z</published>
    <updated>2019-09-25T02:51:01.100Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql-问题篇</title>
    <link href="https://23yue23.github.io/2019/09/25/mysq-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/09/25/mysq-问题篇/</id>
    <published>2019-09-25T02:50:47.000Z</published>
    <updated>2019-09-25T02:59:02.654Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RROR-2002-HY000-Can’t-connect-to-local-MySQL-server-through-socket-‘-tmp-mysql-sock’-2"><a href="#RROR-2002-HY000-Can’t-connect-to-local-MySQL-server-through-socket-‘-tmp-mysql-sock’-2" class="headerlink" title="RROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2)"></a>RROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要原因是mysql 服务没有启动</span><br><span class="line">解决：mysql.server start</span><br></pre></td></tr></table></figure><p>###om.mysql.jdbc.exceptions.jdbc4.CommunicationsException:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">om.mysql.jdbc.exceptions.jdbc4.CommunicationsException:The last packet successfully received from the server was 44,024,462 milliseconds ago.  The last packet sent successfully to the server was 44,024,462 milliseconds ago. is longer than the server configured value of &apos;wait_timeout&apos;. You should consider either expiring and/or testing connection validity before use in your application, increasing the server configured values for client timeouts, or using the Connector/J connection property &apos;autoReconnect=true&apos; to avoid this problem.</span><br></pre></td></tr></table></figure></p><p>解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在连接上添加这个设置</span><br><span class="line">&amp;autoReconnect=true&amp;failOverReadOnly=false</span><br><span class="line">2.每次使用完记得归还连接</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;RROR-2002-HY000-Can’t-connect-to-local-MySQL-server-through-socket-‘-tmp-mysql-sock’-2&quot;&gt;&lt;a href=&quot;#RROR-2002-HY000-Can’t-connect-to-l
      
    
    </summary>
    
      <category term="mysql" scheme="https://23yue23.github.io/categories/mysql/"/>
    
    
      <category term="mysql-问题篇" scheme="https://23yue23.github.io/tags/mysql-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>指导思想</title>
    <link href="https://23yue23.github.io/2019/08/05/%E6%8C%87%E5%AF%BC%E6%80%9D%E6%83%B3/"/>
    <id>https://23yue23.github.io/2019/08/05/指导思想/</id>
    <published>2019-08-05T06:49:05.000Z</published>
    <updated>2019-09-25T02:42:03.495Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习方法：<br>  <a href="http://xugongli.club/2018/10/26/how_to_be_proficient_in_some_field/" target="_blank" rel="noopener">3 w 学习</a></p></blockquote><blockquote><p>提问的智慧：<br><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md" target="_blank" rel="noopener">连接</a></p></blockquote><blockquote><p>一万小时定论：<br><a href="https://mp.weixin.qq.com/s/Z05VcYfXp5tExvdqidmkgw" target="_blank" rel="noopener">一万小时定论</a></p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><blockquote><ol><li><a href="https://tech.meituan.com/2018/04/16/study-vs-work.html" target="_blank" rel="noopener">工作中如何做好技术积累</a></li><li><a href="http://openskill.cn/article/488" target="_blank" rel="noopener">学习新技术的10个技巧</a></li><li><a href></a></li><li><a href></a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习方法：&lt;br&gt;  &lt;a href=&quot;http://xugongli.club/2018/10/26/how_to_be_proficient_in_some_field/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3 w 
      
    
    </summary>
    
      <category term="第三世界" scheme="https://23yue23.github.io/categories/%E7%AC%AC%E4%B8%89%E4%B8%96%E7%95%8C/"/>
    
    
      <category term="指导思想" scheme="https://23yue23.github.io/tags/%E6%8C%87%E5%AF%BC%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>hbase-学习篇</title>
    <link href="https://23yue23.github.io/2019/07/29/hbase-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/07/29/hbase-学习篇/</id>
    <published>2019-07-29T09:48:31.000Z</published>
    <updated>2019-09-25T02:56:53.518Z</updated>
    
    <content type="html"><![CDATA[<p>####HBase的简介</p><blockquote><ol><li>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”；</li><li>就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力；</li><li>HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库；</li><li>另一个不同的是HBase基于列的而不是基于行的模式；<br>一张表的列簇不会超过5个，每个列簇中的列数没有限制；</li></ol></blockquote><p>####HBase的特点</p><blockquote><ol><li>容量大：HBase单表可以有上百亿行、百万列，数据矩阵横向和纵向两个维度所支持的数据量级都非常具有弹性；</li><li>面向列：HBase是面向列的存储和权限控制，并支持独立检索。列式存储，其数据在表中是按照某列存储的，这样在查询只需要少数几个字段的时候，能大大减少读取的数据量；</li><li>多版本：HBase每一个列的数据存储有多个Version（version）；</li><li>稀疏性：为空的列并不占用存储空间，表可以设计的非常稀疏；</li><li>扩展性：底层依赖于HDFS；</li><li>高可靠性：WAL机制保证了数据写入时不会因集群异常而导致写入数据丢失，Replication机制保证了在集群出现严重的问题时，数据不会发生丢失或损坏。而且HBase底层使用HDFS，HDFS本身也有备份；</li><li>高性能：底层的LSM数据结构和Rowkey有序排列等架构上的独特设计，使得HBase具有非常高的写入性能。region切分、主键索引和缓存机制使得HBase在海量数据下具备一定的随机读取性能，该性能针对Rowkey的查询能够达到毫秒级别；</li></ol></blockquote><p>####HBase架构图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####HBase的简介&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”；&lt;/li&gt;
&lt;li&gt;就像Bigtabl
      
    
    </summary>
    
      <category term="hbase" scheme="https://23yue23.github.io/categories/hbase/"/>
    
    
      <category term="hbase-学习篇" scheme="https://23yue23.github.io/tags/hbase-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Pulsar-学习篇</title>
    <link href="https://23yue23.github.io/2019/07/17/Pulsar-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/07/17/Pulsar-学习篇/</id>
    <published>2019-07-17T08:03:32.000Z</published>
    <updated>2019-09-25T02:37:54.019Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.infoq.cn/article/1UaxFKWUhUKTY1t_5gPq" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.infoq.cn/article/1UaxFKWUhUKTY1t_5gPq&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Pulsar" scheme="https://23yue23.github.io/categories/Pulsar/"/>
    
    
      <category term="Pulsar-学习篇" scheme="https://23yue23.github.io/tags/Pulsar-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>广告-学习篇</title>
    <link href="https://23yue23.github.io/2019/07/12/%E5%B9%BF%E5%91%8A-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/07/12/广告-学习篇/</id>
    <published>2019-07-12T09:30:15.000Z</published>
    <updated>2019-09-25T02:40:02.550Z</updated>
    
    <content type="html"><![CDATA[<h4 id="术语理解"><a href="#术语理解" class="headerlink" title="术语理解"></a>术语理解</h4><p>1.<a href="https://cloud.tencent.com/developer/article/1351052" target="_blank" rel="noopener">dsp系统架构</a></p><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><blockquote><ol><li>dsp 业务</li></ol></blockquote><blockquote><p>1.1 <a href="https://blog.csdn.net/LW_GHY/article/details/71455535" target="_blank" rel="noopener">美团DSP广告策略实践</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;术语理解&quot;&gt;&lt;a href=&quot;#术语理解&quot; class=&quot;headerlink&quot; title=&quot;术语理解&quot;&gt;&lt;/a&gt;术语理解&lt;/h4&gt;&lt;p&gt;1.&lt;a href=&quot;https://cloud.tencent.com/developer/article/1351052
      
    
    </summary>
    
      <category term="广告" scheme="https://23yue23.github.io/categories/%E5%B9%BF%E5%91%8A/"/>
    
    
      <category term="广告-学习篇" scheme="https://23yue23.github.io/tags/%E5%B9%BF%E5%91%8A-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>spark-学习篇</title>
    <link href="https://23yue23.github.io/2019/07/12/spark-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/07/12/spark-学习篇/</id>
    <published>2019-07-12T08:53:29.000Z</published>
    <updated>2019-09-25T02:39:01.773Z</updated>
    
    <content type="html"><![CDATA[<h4 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h4><blockquote><ol><li><a href="https://blog.csdn.net/LW_GHY/article/details/50859346" target="_blank" rel="noopener">Spark on yarn有分为两种模式yarn-cluster和yarn-client</a></li></ol></blockquote><blockquote><ol start="2"><li><a href="https://blog.csdn.net/LW_GHY/article/details/52946136" target="_blank" rel="noopener">spark参数总结</a></li><li><a href="https://blog.csdn.net/LW_GHY/article/details/51477065" target="_blank" rel="noopener">spark 常用算子</a></li><li><a href="https://blog.csdn.net/LW_GHY/article/details/51470073" target="_blank" rel="noopener">Spark on YARN客户端模式作业运行全过程分析</a></li></ol></blockquote><hr><h4 id="spark-batch"><a href="#spark-batch" class="headerlink" title="spark batch"></a>spark batch</h4><blockquote><ol><li><a href="https://blog.csdn.net/LW_GHY/article/details/51477100" target="_blank" rel="noopener">Spark多文件输出(MultipleOutputFormat)</a></li></ol></blockquote><blockquote><p>2.spark-mysql 操作</p><blockquote><p>2.1 <a href="https://blog.csdn.net/LW_GHY/article/details/50939091" target="_blank" rel="noopener">Spark读取数据库(Mysql)的四种方式讲解</a></p></blockquote></blockquote><blockquote><blockquote><p>2.2 <a href="https://blog.csdn.net/LW_GHY/article/details/51465125" target="_blank" rel="noopener">Spark与Mysql(JdbcRDD)整合开发</a></p></blockquote></blockquote><blockquote><blockquote><p>2.3 <a href="https://blog.csdn.net/LW_GHY/article/details/51477072" target="_blank" rel="noopener">spark 计算结果写入mysql</a></p></blockquote></blockquote><hr><h4 id="spark-Streaming"><a href="#spark-Streaming" class="headerlink" title="spark Streaming"></a>spark Streaming</h4><blockquote><ol><li><a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#a-quick-example" target="_blank" rel="noopener">官网stream</a></li></ol></blockquote><blockquote><ol start="2"><li><a href="https://blog.csdn.net/LW_GHY/article/details/88867174" target="_blank" rel="noopener">Spark Streaming 实现思路与模块概述</a></li></ol></blockquote><blockquote><ol start="3"><li><a href="https://blog.csdn.net/LW_GHY/article/details/51673081" target="_blank" rel="noopener">SparkStreaming向Hbase中写数据</a></li></ol></blockquote><blockquote><ol start="4"><li><a href="https://blog.csdn.net/LW_GHY/article/details/52143659" target="_blank" rel="noopener">Spark Streaming kafka实现数据零丢失的几种方式</a></li></ol></blockquote><blockquote><ol start="5"><li><a href="https://blog.csdn.net/LW_GHY/article/details/50926956" target="_blank" rel="noopener">Kafka+Spark Streaming+Redis实时系统实践</a></li></ol></blockquote><blockquote><ol start="6"><li><a href="https://blog.csdn.net/LW_GHY/article/details/51477355" target="_blank" rel="noopener">Spark Streaming中空batches处理的两种方法</a></li></ol></blockquote><hr><h4 id="spark-调优"><a href="#spark-调优" class="headerlink" title="spark 调优"></a>spark 调优</h4><blockquote><ol><li><a href="https://blog.csdn.net/LW_GHY/article/details/51419760" target="_blank" rel="noopener">spark性能优化：shuffle调优</a></li></ol></blockquote><blockquote><ol start="2"><li><a href="https://blog.csdn.net/LW_GHY/article/details/51420027" target="_blank" rel="noopener">spark性能调优：开发调优</a></li></ol></blockquote><blockquote><ol start="3"><li><a href="https://blog.csdn.net/LW_GHY/article/details/51419977" target="_blank" rel="noopener">spark性能调优：资源优化</a></li></ol></blockquote><blockquote><ol start="4"><li><a href="https://blog.csdn.net/LW_GHY/article/details/50780940" target="_blank" rel="noopener">Saprk Streaming性能调优</a></li></ol></blockquote><blockquote><ol start="5"><li><a href="https://blog.csdn.net/LW_GHY/article/details/52373749" target="_blank" rel="noopener">GC调优在Spark应用中的实践</a></li></ol></blockquote><blockquote><ol start="6"><li><a href="https://blog.csdn.net/LW_GHY/article/details/88232471" target="_blank" rel="noopener">JVM的GC调优-上</a></li></ol></blockquote><blockquote><ol start="7"><li><a href="https://blog.csdn.net/LW_GHY/article/details/88232638" target="_blank" rel="noopener">JVM的GC调优-下</a></li></ol></blockquote><hr><h4 id="sparkMLib"><a href="#sparkMLib" class="headerlink" title="sparkMLib"></a>sparkMLib</h4><blockquote><p>1.<a href="https://blog.csdn.net/LW_GHY/article/details/54426443" target="_blank" rel="noopener">Spark MLlib训练的广告点击率预测模型</a></p></blockquote><hr><h4 id="案例实践"><a href="#案例实践" class="headerlink" title="案例实践"></a>案例实践</h4><blockquote><ol><li><a href="https://blog.csdn.net/xwc35047/article/details/75309350" target="_blank" rel="noopener">基于Spark streaming的SQL服务实时自动化运维</a></li><li></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;spark&quot;&gt;&lt;a href=&quot;#spark&quot; class=&quot;headerlink&quot; title=&quot;spark&quot;&gt;&lt;/a&gt;spark&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/LW_GHY/a
      
    
    </summary>
    
      <category term="spark" scheme="https://23yue23.github.io/categories/spark/"/>
    
    
      <category term="spark-学习篇" scheme="https://23yue23.github.io/tags/spark-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>kafka-资料篇</title>
    <link href="https://23yue23.github.io/2019/07/12/kafka-%E8%B5%84%E6%96%99%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/07/12/kafka-资料篇/</id>
    <published>2019-07-12T08:39:50.000Z</published>
    <updated>2019-09-25T02:57:34.946Z</updated>
    
    <content type="html"><![CDATA[<h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h4><blockquote><p>1.<a href="https://kafka.apache.org/quickstart" target="_blank" rel="noopener">官网</a></p></blockquote><h4 id="kafka-技术内幕"><a href="#kafka-技术内幕" class="headerlink" title="kafka 技术内幕"></a>kafka 技术内幕</h4><blockquote><ol><li><a href="https://blog.csdn.net/lw_ghy/article/details/51494292" target="_blank" rel="noopener">Kafka技术内幕-日志压缩</a></li></ol></blockquote><h4 id="中文教程"><a href="#中文教程" class="headerlink" title="中文教程"></a>中文教程</h4><blockquote><p>1.<a href="https://www.orchome.com/kafka/index" target="_blank" rel="noopener">kafka</a></p></blockquote><h4 id="kafka-实践"><a href="#kafka-实践" class="headerlink" title="kafka 实践"></a>kafka 实践</h4><blockquote><p>1.<a href="https://blog.csdn.net/LW_GHY/article/details/72900873" target="_blank" rel="noopener">kafka broker的常用配置</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;官网&quot;&gt;&lt;a href=&quot;#官网&quot; class=&quot;headerlink&quot; title=&quot;官网&quot;&gt;&lt;/a&gt;官网&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1.&lt;a href=&quot;https://kafka.apache.org/quickstart&quot; target=&quot;_
      
    
    </summary>
    
      <category term="kafka" scheme="https://23yue23.github.io/categories/kafka/"/>
    
    
      <category term="kafka-资料篇" scheme="https://23yue23.github.io/tags/kafka-%E8%B5%84%E6%96%99%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>kafka-问题篇</title>
    <link href="https://23yue23.github.io/2019/07/11/kafka-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/07/11/kafka-问题篇/</id>
    <published>2019-07-11T02:23:16.000Z</published>
    <updated>2019-09-25T02:57:59.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="No-resolvable-bootstrap-urls-given-in-bootstrap-servers"><a href="#No-resolvable-bootstrap-urls-given-in-bootstrap-servers" class="headerlink" title="No resolvable bootstrap urls given in bootstrap.servers"></a>No resolvable bootstrap urls given in bootstrap.servers</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">说明当前的bootstrap.servers 填写不正确或者未再配置conf 中设置</span><br><span class="line"></span><br><span class="line">conf 基础配置</span><br><span class="line"></span><br><span class="line">val props = parameterTool.getProperties</span><br><span class="line">    //判断是线上还是线下</span><br><span class="line">if (parameterTool.get(ENV_STATE_FLAG) == &quot;online&quot;) props.put(&quot;bootstrap.servers&quot;, parameterTool.get(KAFKA_ONLINE_BROKERS))</span><br><span class="line">else props.put(&quot;bootstrap.servers&quot;, parameterTool.get(KAFKA_OFFLINE_BROKERS))</span><br><span class="line">    props.put(&quot;group.id&quot;, parameterTool.get(&quot;groupId&quot;))</span><br><span class="line">    props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;)</span><br><span class="line">    props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;)</span><br><span class="line">    props.put(&quot;auto.offset.reset&quot;, &quot;latest&quot;)</span><br><span class="line">    props</span><br></pre></td></tr></table></figure><hr><h4 id="写kafka-超时"><a href="#写kafka-超时" class="headerlink" title="写kafka 超时"></a>写kafka 超时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: </span><br><span class="line">org.apache.kafka.common.errors.TimeoutException: </span><br><span class="line">Expiring 23 record(s) for Topic: 30001 ms has passed since last append</span><br></pre></td></tr></table></figure><p>解决方法：<br>  查看 request.timeout.ms=120000 （defalt 30s）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;No-resolvable-bootstrap-urls-given-in-bootstrap-servers&quot;&gt;&lt;a href=&quot;#No-resolvable-bootstrap-urls-given-in-bootstrap-servers&quot; class=&quot;h
      
    
    </summary>
    
      <category term="kafka" scheme="https://23yue23.github.io/categories/kafka/"/>
    
    
      <category term="kafka-问题篇" scheme="https://23yue23.github.io/tags/kafka-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>hexo-常用篇</title>
    <link href="https://23yue23.github.io/2019/07/10/hexo-%E5%B8%B8%E7%94%A8%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/07/10/hexo-常用篇/</id>
    <published>2019-07-10T03:23:08.000Z</published>
    <updated>2019-09-25T02:46:05.682Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建新文件"><a href="#创建新文件" class="headerlink" title="创建新文件"></a>创建新文件</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在当前总目录下</span><br><span class="line">hexo new &quot;hexo之基本操作&quot;</span><br></pre></td></tr></table></figure><h4 id="清除缓存更新部署"><a href="#清除缓存更新部署" class="headerlink" title="清除缓存更新部署"></a>清除缓存更新部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;创建新文件&quot;&gt;&lt;a href=&quot;#创建新文件&quot; class=&quot;headerlink&quot; title=&quot;创建新文件&quot;&gt;&lt;/a&gt;创建新文件&lt;/h4&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="hexo" scheme="https://23yue23.github.io/categories/hexo/"/>
    
    
      <category term="hexo-常用篇" scheme="https://23yue23.github.io/tags/hexo-%E5%B8%B8%E7%94%A8%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>linux-常用篇</title>
    <link href="https://23yue23.github.io/2019/07/10/linux-%E5%B8%B8%E7%94%A8%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/07/10/linux-常用篇/</id>
    <published>2019-07-10T03:22:41.000Z</published>
    <updated>2019-09-25T02:38:27.260Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Bash-快捷键"><a href="#Bash-快捷键" class="headerlink" title="Bash 快捷键"></a>Bash 快捷键</h4><p>Ctl-U   删除光标到行首的所有字符,在某些设置下,删除全行<br>Ctl-W   删除当前光标到前边的最近一个空格之间的字符</p><p>文件</p><ol><li>删除文件： rm -rf  <em>log  等加于$ find ./ -name “</em>log” -exec rm {} </li><li>搜寻文件或目录: $find ./ -name “core*” | xargs file</li><li>查找所有非txt文本: find . ! -name “*.txt” -print</li><li>统计文本中123 出现的个数： grep -c “123” filename</li><li>sort 排序：-n 按数字进行排序 VS -d 按字典序进行排序 -r 逆序排序  -k N 指定按第N列排序 ：sort -n -1k -2k    sort -bd data // 忽略像空格之类的前导空白字符</li><li>拼接文本 paste file1 file2</li></ol><p>系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># uname -a               # 查看内核/操作系统/CPU信息</span><br><span class="line"># head -n 1 /etc/issue   # 查看操作系统版本</span><br><span class="line"># cat /proc/cpuinfo      # 查看CPU信息</span><br><span class="line"># hostname               # 查看计算机名</span><br><span class="line"># lspci -tv              # 列出所有PCI设备</span><br><span class="line"># lsusb -tv              # 列出所有USB设备</span><br><span class="line"># lsmod                  # 列出加载的内核模块</span><br><span class="line"># env                    # 查看环境变量</span><br><span class="line">资源</span><br><span class="line"># free -m                # 查看内存使用量和交换区使用量</span><br><span class="line"># df -h                  # 查看各分区使用情况</span><br><span class="line"># du -sh &lt;目录名&gt;        # 查看指定目录的大小</span><br><span class="line"># grep MemTotal /proc/meminfo   # 查看内存总量</span><br><span class="line"># grep MemFree /proc/meminfo    # 查看空闲内存量</span><br><span class="line"># uptime                 # 查看系统运行时间、用户数、负载</span><br><span class="line"># cat /proc/loadavg      # 查看系统负载</span><br></pre></td></tr></table></figure><h4 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mount | column -t      # 查看挂接的分区状态</span><br><span class="line"># fdisk -l               # 查看所有分区</span><br><span class="line"># swapon -s              # 查看所有交换分区</span><br><span class="line"># hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)</span><br><span class="line"># dmesg | grep IDE       # 查看启动时IDE设备检测状况</span><br></pre></td></tr></table></figure><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig               # 查看所有网络接口的属性</span><br><span class="line"># iptables -L            # 查看防火墙设置</span><br><span class="line"># route -n               # 查看路由表</span><br><span class="line"># netstat -lntp          # 查看所有监听端口</span><br><span class="line"># netstat -antp          # 查看所有已经建立的连接</span><br><span class="line"># netstat -s             # 查看网络统计信息</span><br></pre></td></tr></table></figure><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ps -ef                 # 查看所有进程</span><br><span class="line"># top                    # 实时显示进程状态</span><br></pre></td></tr></table></figure><h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># w                      # 查看活动用户</span><br><span class="line"># id &lt;用户名&gt;            # 查看指定用户信息</span><br><span class="line"># last                   # 查看用户登录日志</span><br><span class="line"># cut -d: -f1 /etc/passwd   # 查看系统所有用户</span><br><span class="line"># cut -d: -f1 /etc/group    # 查看系统所有组</span><br><span class="line"># crontab -l             # 查看当前用户的计划任务</span><br></pre></td></tr></table></figure><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig --list       # 列出所有系统服务</span><br><span class="line"># chkconfig --list | grep on    # 列出所有启动的系统服务</span><br></pre></td></tr></table></figure><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rpm -qa                # 查看所有安装的软件包</span><br></pre></td></tr></table></figure><h4 id="Shell-脚本执行返回状态码："><a href="#Shell-脚本执行返回状态码：" class="headerlink" title="Shell 脚本执行返回状态码："></a>Shell 脚本执行返回状态码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 命令成功完成</span><br><span class="line">1通常的未知错误</span><br><span class="line">2误用shell命令</span><br><span class="line">126命令无法执行</span><br><span class="line">127没有找到命令</span><br><span class="line">128无效的退出参数</span><br><span class="line">128+x使用Linux信号x的致命错误。</span><br><span class="line">130使用Ctrl-C终止的命令</span><br><span class="line">255规范外的退出状态</span><br></pre></td></tr></table></figure><h4 id="技巧："><a href="#技巧：" class="headerlink" title="技巧："></a>技巧：</h4><blockquote><p>1.查看变量是否被声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 :- 来测试是否一个变量是否被声明过。</span><br><span class="line">如：if [ &quot;$&#123;NAME:-&#125;&quot; = &quot;Kevin&quot; ] 如果 $&#123;NAME&#125;变量未声明则会变为空字符，你也可以设置为其他默认值.</span><br><span class="line">例如：如果不存在，默认值设为：noname ，if [ &quot;$&#123;NAME:-noname&#125;&quot; = &quot;Kevin” ]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>2.自定义shell命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc 中设置命令别名:</span><br><span class="line">alias lsl=&apos;ls -lrt&apos;</span><br><span class="line">alias lm=&apos;ls -al|more’</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>3.shell文本格式化代码：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gg=G</span><br></pre></td></tr></table></figure></p></blockquote><hr><h4 id="vi-快捷建"><a href="#vi-快捷建" class="headerlink" title="vi 快捷建"></a>vi 快捷建</h4><p>A               移动光标到当前行尾，并进入 insert 状态<br>a               在当前位置后进入 insert 状态<br>dd              删除当前行<br>D               删除光标之后的内容<br>p               粘贴刚删除的文本<br>ctrl+r          搜索历史命令<br>ctrl+X Ctrl+E   调用默认编辑器去编辑一个特别长的命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Bash-快捷键&quot;&gt;&lt;a href=&quot;#Bash-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Bash 快捷键&quot;&gt;&lt;/a&gt;Bash 快捷键&lt;/h4&gt;&lt;p&gt;Ctl-U   删除光标到行首的所有字符,在某些设置下,删除全行&lt;br&gt;Ctl-W   删除
      
    
    </summary>
    
      <category term="linux" scheme="https://23yue23.github.io/categories/linux/"/>
    
    
      <category term="linux-常用篇" scheme="https://23yue23.github.io/tags/linux-%E5%B8%B8%E7%94%A8%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>cassandra-优化篇</title>
    <link href="https://23yue23.github.io/2019/05/17/cassandra-%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/05/17/cassandra-优化篇/</id>
    <published>2019-05-17T07:04:40.000Z</published>
    <updated>2019-09-25T02:55:54.667Z</updated>
    
    <content type="html"><![CDATA[<p>Cassandra不同于普通的应用程序，它是分布式数据库，它要大口吃内存，吃磁盘，吃CPU，所以机器要进行特殊的配置，以适应其需要。</p><h4 id="使用最新的64位的jdk8的最新发布版本。"><a href="#使用最新的64位的jdk8的最新发布版本。" class="headerlink" title="使用最新的64位的jdk8的最新发布版本。"></a>使用最新的64位的jdk8的最新发布版本。</h4><hr><h4 id="时钟同步，开启NTP服务"><a href="#时钟同步，开启NTP服务" class="headerlink" title="时钟同步，开启NTP服务."></a>时钟同步，开启NTP服务.</h4><blockquote><p>cassandra是分布式存储，就靠时间戳解决数据冲突，所以始终必须同步</p></blockquote><hr><h4 id="TCP参数设置"><a href="#TCP参数设置" class="headerlink" title="TCP参数设置"></a>TCP参数设置</h4><blockquote><p>在低带宽环境下，防火墙会检测闲置的连接并关闭，为了保护节点之间，或者多个DC节点之间的连接，建议如下配置系统参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w</span><br><span class="line">net.ipv4.tcp_keepalive_time=60</span><br><span class="line">net.ipv4.tcp_keepalive_probes=3</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=10</span><br></pre></td></tr></table></figure><blockquote><p>设置这个就是可以快速的发现底层的TCP连接是否已经关闭，它间隔60秒开始探测3次，每次探测间隔10秒，也就是说最多在60+3*10=90秒内就可以检测到连接被中断。<br>为了支撑上千个数据库连接，还建议修改以下参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.core.rmem_default=16777216</span><br><span class="line">net.core.wmem_default=16777216</span><br><span class="line">net.core.optmem_max=40960</span><br><span class="line">net.ipv4.tcp_rmem=4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem=4096 65536 16777216</span><br></pre></td></tr></table></figure><blockquote><p>为了让参数永久生效，记得把它们写入系统配置文件/etc/sysctl.conf里</p></blockquote><hr><h4 id="禁用CPU动态跳频功能。"><a href="#禁用CPU动态跳频功能。" class="headerlink" title="禁用CPU动态跳频功能。"></a>禁用CPU动态跳频功能。</h4><blockquote><p>最近的linux系统增加了一个新特性，就是可以动态调整CPU频率，就是在机器低负载的时候，可以降低CPU频率，以达到降低功耗的目的。<br>这种动态调频功能会影响cassandra数据库的吞吐量。建议禁用，让CPU一直维持恒定的频率输出，尽管这很耗电，但是保证你的数据库的吞吐量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">禁用方式：</span><br><span class="line"></span><br><span class="line">for CPUFREQ in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor</span><br><span class="line">do</span><br><span class="line">[ -f $CPUFREQ ] || continue</span><br><span class="line">echo -n performance &gt; $CPUFREQ</span><br><span class="line">done</span><br></pre></td></tr></table></figure><hr><h4 id="禁用zone-reclaim-mode"><a href="#禁用zone-reclaim-mode" class="headerlink" title="禁用zone_reclaim_mode"></a>禁用zone_reclaim_mode</h4><blockquote><p>官方建议禁用，这个是关于多核CPU使用NUMA架构，分别访问内存，内存回收方面的一个参数<br>这个参数的解释，可以参考：<br><a href="http://linuxinsight.com/proc_sys_vm_zone_reclaim_mode.html" target="_blank" rel="noopener">http://linuxinsight.com/proc_sys_vm_zone_reclaim_mode.html</a><br>这里面有一句话，当你的机器用作文件服务器，或者你的大部分内存需要用于系统文件缓存的时候，你需要禁用这个功能。<br>我们的Cassandra就相当于文件服务器，它对IO是依赖的，它需要系统内存用于大量缓存DB文件。所以要禁用这个功能。<br>echo 0 &gt; /proc/sys/vm/zone_reclaim_mode<br>Cassandra官方描述了如果不禁用这个参数带来的后果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、随机CPU尖峰带来时延增加，吞吐量增加。</span><br><span class="line">2、程序假死，什么也不做。</span><br><span class="line">3、一些突然发生又消失的莫名异常。</span><br><span class="line">4、重启机器，可能在一段时间内不再出现异常。</span><br></pre></td></tr></table></figure><hr><h4 id="资源限制放开。"><a href="#资源限制放开。" class="headerlink" title="资源限制放开。"></a>资源限制放开。</h4><blockquote><p>cassandra会使用很多内存，很多连接，很多文件，所以一律放开。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;cassandra_user&gt; – memlock unlimited</span><br><span class="line">&lt;cassandra_user&gt; – nofile 100000</span><br><span class="line">&lt;cassandra_user&gt; – nproc 32768</span><br><span class="line">&lt;cassandra_user&gt; – as unlimited</span><br></pre></td></tr></table></figure><blockquote><p>这个加入到/etc/security/limits.conf 里（不同操作系统，可能不同，后面不再注明）<br>vm.max_map_count = 1048575   将这个加入到 /etc/sysctl.conf 里</p></blockquote><hr><h4 id="禁用swap"><a href="#禁用swap" class="headerlink" title="禁用swap"></a>禁用swap</h4><blockquote><p>关闭 sudo swapoff –all<br>修改 /etc/fstab. 去掉swap挂载。<br>swap文件内存交换区，当你的内存不够的时候，使用文件内存，这会让你的数据库卡成狗的，一律禁用。</p></blockquote><hr><h4 id="文件预"><a href="#文件预" class="headerlink" title="文件预"></a>文件预</h4><blockquote><p>默认保持64k即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 64 &gt; /sys/class/block/&#123;sda&#125;/queue/read_ahead_kb</span><br></pre></td></tr></table></figure><blockquote><p>如果是ssd，设置为8k</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 8 &gt; /sys/class/block/&#123;sda&#125;/queue/read_ahead_kb</span><br></pre></td></tr></table></figure><blockquote><p>如果是ssd，还要设置下面的参数进行优化。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo deadline &gt; /sys/block/sda/queue/scheduler</span><br><span class="line">#OR…</span><br><span class="line">#echo noop &gt; /sys/block/sda/queue/scheduler</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">echo 0 &gt; /sys/class/block/sda/queue/rotational</span><br></pre></td></tr></table></figure><hr><h4 id="确保以上参数重启机器后仍然有效。"><a href="#确保以上参数重启机器后仍然有效。" class="headerlink" title="确保以上参数重启机器后仍然有效。"></a>确保以上参数重启机器后仍然有效。</h4><hr><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://zhaoyanblog.com/archives/1005.html" target="_blank" rel="noopener">赵岩的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cassandra不同于普通的应用程序，它是分布式数据库，它要大口吃内存，吃磁盘，吃CPU，所以机器要进行特殊的配置，以适应其需要。&lt;/p&gt;
&lt;h4 id=&quot;使用最新的64位的jdk8的最新发布版本。&quot;&gt;&lt;a href=&quot;#使用最新的64位的jdk8的最新发布版本。&quot; cl
      
    
    </summary>
    
      <category term="Cassandra" scheme="https://23yue23.github.io/categories/Cassandra/"/>
    
    
      <category term="cassandra-优化篇" scheme="https://23yue23.github.io/tags/cassandra-%E4%BC%98%E5%8C%96%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>linux-问题篇</title>
    <link href="https://23yue23.github.io/2019/05/17/linux-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/05/17/linux-问题篇/</id>
    <published>2019-05-17T06:51:25.000Z</published>
    <updated>2019-09-25T02:36:52.723Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:80</span><br></pre></td></tr></table></figure><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp|grep port</span><br></pre></td></tr></table></figure><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><h4 id="flind"><a href="#flind" class="headerlink" title="flind"></a>flind</h4><h4 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h4><p><a href></a></p><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p><a href="http://man.linuxde.net/curl" target="_blank" rel="noopener">curl</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;lsof&quot;&gt;&lt;a href=&quot;#lsof&quot; class=&quot;headerlink&quot; title=&quot;lsof&quot;&gt;&lt;/a&gt;lsof&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="linux" scheme="https://23yue23.github.io/categories/linux/"/>
    
    
      <category term="linux-问题篇" scheme="https://23yue23.github.io/tags/linux-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>cassandra-问题篇</title>
    <link href="https://23yue23.github.io/2019/05/17/cassandra-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/05/17/cassandra-问题篇/</id>
    <published>2019-05-17T06:17:21.000Z</published>
    <updated>2019-09-25T02:52:06.328Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么不可以设置listen-address为0-0-0-0（意思是监听所有地址）？"><a href="#为什么不可以设置listen-address为0-0-0-0（意思是监听所有地址）？" class="headerlink" title="为什么不可以设置listen_address为0.0.0.0（意思是监听所有地址）？"></a>为什么不可以设置listen_address为0.0.0.0（意思是监听所有地址）？</h4><blockquote><p>Cassandra是一个基于gossip协议的分布式系统，监听地址是用来告诉其它节点来访问的，告诉别的节点说“连接我任何地址都可以”，是一个糟糕的想法，如果集群中不同的节点使用了不同方式的地址，悲剧的事情就要发生了。<br>如果你不想为你集群中的每个节点单独配置ip（非常可以理解）,你可以不配，空着它，Cassandra将会使用InetAddress.getLocalHost()来选择地址，然后只要你或者你的运维团队保证这个是正确的(/etc/hosts/,dns 等等要配置对)。<br>一个例外是JMX,他默认监听的地址是0.0.0.0（这个是java的bug 6425769）<br>请看CASSANDRA-256 和 CASSANDRA-43获取这方面更多的细节。</p></blockquote><hr><h4 id="cassandra用了哪些端口？"><a href="#cassandra用了哪些端口？" class="headerlink" title="cassandra用了哪些端口？"></a>cassandra用了哪些端口？</h4><blockquote><p>默认7000作为集群通信端口（如果开启了SSL就是7001端口）。<br>9042端口用于native协议的客户端连接。<br>7199端口用于JMX，<br>9160端口用于废弃的Thrift接口。<br>内部节点通信以及native协议的端口在cassandra配置文件里可以配置。JMX端口可以在cassandra-env.sh配置（通过JVM的参数)。所有端口都是TCP的。</p></blockquote><hr><h4 id="当往集群中增加新节点的时候，对于存在的数据发生了什么？"><a href="#当往集群中增加新节点的时候，对于存在的数据发生了什么？" class="headerlink" title="当往集群中增加新节点的时候，对于存在的数据发生了什么？"></a>当往集群中增加新节点的时候，对于存在的数据发生了什么？</h4><blockquote><p>当一个新节点加入到集群，它将会自动连接集群中的其它节点，并且去复制正确的数据到本地，同样的增加、替换、移动、删除节点都是这样的。</p></blockquote><hr><h4 id="我删除了数据，但是磁盘使用率没有变化，这是为什么？"><a href="#我删除了数据，但是磁盘使用率没有变化，这是为什么？" class="headerlink" title="我删除了数据，但是磁盘使用率没有变化，这是为什么？"></a>我删除了数据，但是磁盘使用率没有变化，这是为什么？</h4><blockquote><p>写入到cassandra里的数据会被持久化到SSTable文件里，SSTable文件是不可改变的，也就是说当你执行删除的时候，数据不会从文件中被去除掉的。<br>相反，一个标记（也叫tombstone)会被写入用于标记对应记录的新状态。不用担心，当数据和tombstone发生第一次compaction的时候，数据会被删除掉，相应的磁盘空间也被回收，你可以了解关于Compaction的更多细节。</p></blockquote><hr><h4 id="为什么用nodetool-ring只能看到一条记录？-即便所有节点输出的日志里可以看出，他们都发现彼此加入到了这个ring。"><a href="#为什么用nodetool-ring只能看到一条记录？-即便所有节点输出的日志里可以看出，他们都发现彼此加入到了这个ring。" class="headerlink" title="为什么用nodetool ring只能看到一条记录？ 即便所有节点输出的日志里可以看出，他们都发现彼此加入到了这个ring。"></a>为什么用nodetool ring只能看到一条记录？ 即便所有节点输出的日志里可以看出，他们都发现彼此加入到了这个ring。</h4><blockquote><p>这个发生于你的所有节点都配了通用的token，不要这么做。<br>这经常发生于哪些使用VM部署cassandra的用户，（特别是使用Debian package，它会在安装完自动启动cassandra，所以会生成token并保存它。），安装好后就把VM整个克隆出另外的节点。<br>增很容易修复，只要把数据目录以及commitlog目录删除，然后保证每个节点是随机生成的token，再启动就可以了。</p></blockquote><hr><h4 id="我可以修改一个正在运行中的集群中的keyspace的副本因子吗？"><a href="#我可以修改一个正在运行中的集群中的keyspace的副本因子吗？" class="headerlink" title="我可以修改一个正在运行中的集群中的keyspace的副本因子吗？"></a>我可以修改一个正在运行中的集群中的keyspace的副本因子吗？</h4><blockquote><p>可以，但是修改后需要执行repair或者cleanup来改变已存数据的副本个数。<br>首先使用cqlsh修改目标keyspace的副本因子。<br>如果你是减少副本因子，你可以执行nodetool cleanup去删除多余的副本数据，对每个节点都要执行。<br>如果你是增加副本因子，你需要执行nodetool repair来保证数据的副本个数满足当前的配置。 Repair只要对每个副本集执行一次即可。这是个敏感的操作，这会影响集群的性能。强烈建议执行rolling repair，因为试图一次修复整个集群的话，那可能是个坑。</p></blockquote><hr><h4 id="可以使用cassandra存储大的二进制字段吗？"><a href="#可以使用cassandra存储大的二进制字段吗？" class="headerlink" title="可以使用cassandra存储大的二进制字段吗？"></a>可以使用cassandra存储大的二进制字段吗？</h4><blockquote><p>Cassandra并没有对存储大文件或者二进制，以及这样一个二进制数据被经常读，也就是整个发送到客户端的情况进行优化。因为存储小的二进制数据（小于1MB)应该不是问题。但是还是建议把大的二进制数据分隔成小块。<br>需要特别注意的是，任何大于16MB的值，将被Cassandra拒绝掉，这是由max_mutation_size_in_kb配置项决定的（这个配置项默认是commitlog_segment_size_in_mb的一半，commitlog_segment_size_in_mb默认是32M)。</p></blockquote><hr><h4 id="Nodetool连接远程服务器的时候，提示“Connection-refused-to-host-127-0-1-1”-，这是为什么？"><a href="#Nodetool连接远程服务器的时候，提示“Connection-refused-to-host-127-0-1-1”-，这是为什么？" class="headerlink" title="Nodetool连接远程服务器的时候，提示“Connection refused to host: 127.0.1.1” ，这是为什么？"></a>Nodetool连接远程服务器的时候，提示“Connection refused to host: 127.0.1.1” ，这是为什么？</h4><blockquote><p>nodetool依赖JMX，JMX依赖RMI。RMI在两端通信的时候会根据需要创建自己的listenners和connectors。通常，这些都是底层透明的，但是不正确的hostname解析，无论是在连接方还是被连接方，都会导致错乱和这样的拒绝异常。<br>如果你在使用DNS。确保两端机器的/etc/hosts文件是正确的。如果还是失败的，你可以尝试通过jvm选项-Djava.rmi.server.hostname=指定你要连接的远程机器名称给JMX接口，配置项大体在cassandra-env.sh文件的靠下的位置。</p></blockquote><hr><h4 id="端口占用"><a href="#端口占用" class="headerlink" title="端口占用"></a>端口占用</h4><blockquote><p>错误：<br> Cassandra关闭后，重启，提示，7199端口被占用，分析原因是关闭时使用的ctrl+c，实际上并没有关闭cassandra服务进程，所以提示端口已被使用； </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yxcdeMacBook-Pro:3.11.4 yxc$ cqlsh</span><br><span class="line">Connection error: (&apos;Unable to connect to any servers&apos;, &#123;&apos;127.0.0.1&apos;: error(61, &quot;Tried connecting to [(&apos;127.0.0.1&apos;, 9042)]. Last error: Connection refused&quot;)&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>解决：<br>找出使用7199端口的进程<br>lsof -i:7199<br>杀死残留进程<br>kill direct_pid</p></blockquote><hr><h4 id="版本不一致"><a href="#版本不一致" class="headerlink" title="版本不一致"></a>版本不一致</h4><blockquote><p>错误： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection error: </span><br><span class="line">(‘Unable to connect to any servers’, </span><br><span class="line">&#123;‘127.0.0.1’: ProtocolError(“cql_version ‘3.3.0’ is not supported by remote (w/ native protocol). Supported versions: [u’3.3.1’]”,)&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>解决： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改cassandra_home/bin/cqlsh.py: </span><br><span class="line">DEFAULT_CQLVER = ‘3.3.0’为DEFAULT_CQLVER = ‘3.3.1’；</span><br></pre></td></tr></table></figure><hr><h4 id="All-host-s-tried-for-query-failed"><a href="#All-host-s-tried-for-query-failed" class="headerlink" title="All host(s) tried for query failed"></a>All host(s) tried for query failed</h4><blockquote><p>错误： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message: ‘All host(s) tried for query failed. First host tried, </span><br><span class="line">127.0.0.1:9042: Error: connect ECONNREFUSED 127.0.0.1:9042. </span><br><span class="line">See innerErrors.’ &#125;</span><br></pre></td></tr></table></figure><blockquote><p>解决： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改cassandra_home/conf/cassandra.yaml: </span><br><span class="line">start_native_transport=false改为start_native_transport=true;</span><br></pre></td></tr></table></figure><hr><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhaoyanblog.com/archives/957.html" target="_blank" rel="noopener">赵岩</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么不可以设置listen-address为0-0-0-0（意思是监听所有地址）？&quot;&gt;&lt;a href=&quot;#为什么不可以设置listen-address为0-0-0-0（意思是监听所有地址）？&quot; class=&quot;headerlink&quot; title=&quot;为什么不可以设置
      
    
    </summary>
    
      <category term="cassandra" scheme="https://23yue23.github.io/categories/cassandra/"/>
    
    
      <category term="cassandra-问题篇" scheme="https://23yue23.github.io/tags/cassandra-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Druid-学习篇</title>
    <link href="https://23yue23.github.io/2019/05/17/Druid-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/05/17/Druid-学习篇/</id>
    <published>2019-05-17T05:49:39.000Z</published>
    <updated>2019-09-25T02:37:16.186Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="https://blog.csdn.net/bigtree_3721/article/category/6956082" target="_blank" rel="noopener">druid 系列csdn</a></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/bigtree_3721/article/category/6956082&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;druid 系列csdn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li
      
    
    </summary>
    
      <category term="Druid" scheme="https://23yue23.github.io/categories/Druid/"/>
    
    
      <category term="Druid-学习篇" scheme="https://23yue23.github.io/tags/Druid-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew-使用篇</title>
    <link href="https://23yue23.github.io/2019/05/17/Homebrew-%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/05/17/Homebrew-使用篇/</id>
    <published>2019-05-17T02:56:28.000Z</published>
    <updated>2019-09-25T02:34:24.410Z</updated>
    
    <content type="html"><![CDATA[<p>安装路径：/usr/local/Cellar/</p><blockquote><p>查找软件包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search wget</span><br></pre></td></tr></table></figure><blockquote><p>安装软件包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install wget</span><br></pre></td></tr></table></figure><blockquote><p>列出已安装的软件包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew list</span><br></pre></td></tr></table></figure><blockquote><p>删除软件包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew remove wget</span><br></pre></td></tr></table></figure><blockquote><p>查看软件包信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info wget</span><br></pre></td></tr></table></figure><blockquote><p>列出软件包的依赖关系</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew deps wget</span><br></pre></td></tr></table></figure><blockquote><p>更新brew</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure><blockquote><p>列出过时的软件包（已安装但不是最新版本）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew outdated</span><br></pre></td></tr></table></figure><blockquote><p>更新过时的软件包（全部或指定）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew upgrade 或 brew upgrade wget</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装路径：/usr/local/Cellar/&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查找软件包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="工具" scheme="https://23yue23.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Homebrew-使用篇" scheme="https://23yue23.github.io/tags/Homebrew-%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>cassandra-常用篇</title>
    <link href="https://23yue23.github.io/2019/05/15/cassandra-%E5%B8%B8%E7%94%A8%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/05/15/cassandra-常用篇/</id>
    <published>2019-05-15T09:33:51.000Z</published>
    <updated>2019-09-25T02:54:39.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.myoak.info/post/12/" target="_blank" rel="noopener">cassandra mac os 安装</a></p></blockquote><h4 id="shell-命令"><a href="#shell-命令" class="headerlink" title="shell 命令"></a>shell 命令</h4><h5 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cqlsh -u cassandra -p cassandra --connect-timeout 300</span><br></pre></td></tr></table></figure><h5 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodetool  describecluster</span><br></pre></td></tr></table></figure><h5 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodetool    status</span><br></pre></td></tr></table></figure><h5 id="重启节点"><a href="#重启节点" class="headerlink" title="重启节点"></a>重启节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart scylla-server</span><br></pre></td></tr></table></figure><h4 id="Cql操作"><a href="#Cql操作" class="headerlink" title="Cql操作"></a>Cql操作</h4><h5 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VERSION</span><br></pre></td></tr></table></figure><h5 id="keyspaces-操作"><a href="#keyspaces-操作" class="headerlink" title="keyspaces 操作"></a>keyspaces 操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看</span><br><span class="line">desc keyspaces;</span><br><span class="line">#使用</span><br><span class="line">use keyspaceName</span><br></pre></td></tr></table></figure><h5 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#table list</span><br><span class="line">describe tables;</span><br><span class="line"></span><br><span class="line">#查看表结构</span><br><span class="line">describe table table_name;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.myoak.info/post/12/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cassandra mac os 安装&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;sh
      
    
    </summary>
    
      <category term="cassandra" scheme="https://23yue23.github.io/categories/cassandra/"/>
    
    
      <category term="cassandra-常用篇" scheme="https://23yue23.github.io/tags/cassandra-%E5%B8%B8%E7%94%A8%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>cassandra-学习篇</title>
    <link href="https://23yue23.github.io/2019/05/15/cassandra-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/05/15/cassandra-学习篇/</id>
    <published>2019-05-15T08:52:03.000Z</published>
    <updated>2019-09-25T02:53:00.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>Apache Cassandra 是一个开源的、分布式、无中心、弹性可扩展、高可用、容错、一致性可调、面向行的数据库，它基于 Amazon Dynamo 的分布式设计和 Google Bigtable 的数据模型，Cassandra 其协议是 P2P 的，并使用 gossip 来维护存活或死亡节点的列表（gossip 协议介绍：<a href="https://www.iteblog.com/archives/2505.html）由" target="_blank" rel="noopener">https://www.iteblog.com/archives/2505.html）由</a> Facebook 创建，在一些最流行的网站中得到应用.</p></blockquote><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><h4 id="分布式和去中心化（Distributed-and-Decentralized）："><a href="#分布式和去中心化（Distributed-and-Decentralized）：" class="headerlink" title="分布式和去中心化（Distributed and Decentralized）："></a>分布式和去中心化（Distributed and Decentralized）：</h4><blockquote><p>可以运行在多台机器上，并呈现给用户一个一致的整体；</p></blockquote><blockquote><p>Cassandra 是无中心的，也就是说每个节点都是一样的，协议是 P2P 的，并使用 gossip 来维护存活或死亡节点的列表。</p></blockquote><h4 id="弹性可扩展："><a href="#弹性可扩展：" class="headerlink" title="弹性可扩展："></a>弹性可扩展：</h4><blockquote><p>集群可以不间断的情况下，方便扩展或缩减服务的规模，不需要重新启动进程，不必修改应用的查询，也无需自己手工重新均衡数据分布，只要加入新的计算机，Cassandra 就会自动地发现它并让它开始工作。</p></blockquote><h4 id="高可用和容错："><a href="#高可用和容错：" class="headerlink" title="高可用和容错："></a>高可用和容错：</h4><blockquote><p>可以在不中断系统的情况下替换故障节点，还可以把数据分布到多个数据中心里，从而提供更好的本地访问性能，并且在某一数据中心发生火灾、洪水等不可抗灾难的时候防止系统彻底瘫痪</p></blockquote><h4 id="可调节一致性："><a href="#可调节一致性：" class="headerlink" title="可调节一致性："></a>可调节一致性：</h4><blockquote><ol><li>通过副本因子（replication factor），你可以决定准备牺牲多少性能来换取一致性。 副本因子是你要求更新在集群中传播到的节点数（注意，更新包括所有增加、删除和更新操作）。</li></ol></blockquote><blockquote><ol start="2"><li>一致性级别（consistency level）参数，这个参数决定了多少个副本写入成功才可以认定写操作是成功的，或者读取过程中读到多少个副本正确就可以认定是读成功的。这里 Cassandra 把决定一致性程度的权利留给了客户自己。</li></ol></blockquote><blockquote><ol start="3"><li>所以，如果需要的话，你可以设定一致性级别和副本因子相等，从而达到一个较高的一致性水平，不过这样就必须付出同步阻塞操作的代价，只有所有节点都被更新完成才能成功返回一次更新。而实际上，Cassandra 一般都不会这么来用，原因显而易见（这样就丧失了可用性目标，影响性能，而且这不是你选择 Cassandra 的初衷）。而如果一个客户端设置一致性级别低于副本因子的话，即使有节点宕机了，仍然可以写成功。</li></ol></blockquote><blockquote><ol start="4"><li>总体来说，Cassandra 更倾向于 CP，虽然它也可以通过调节一致性水平达到 AP；但是不推荐你这么设置。其CAP 定律的详细介绍可参见<a href="https://www.iteblog.com/archives/2352.html" target="_blank" rel="noopener">《分布式系统一致性问题、CAP定律以及 BASE 理论》</a>以及<a href="https://www.iteblog.com/archives/2390.html" target="_blank" rel="noopener">《一篇文章搞清楚什么是分布式系统 CAP 定理》</a>。</li></ol></blockquote><h4 id="面向行"><a href="#面向行" class="headerlink" title="面向行"></a>面向行</h4><blockquote><p>它的数据结构不是关系型的，而是一个多维稀疏哈希表。稀疏（Sparse）意味着任何一行都可能会有一列或者几列。更确切地说，应该把 Cassandra 看做是一个有索引的、面向行的存储系统。</p></blockquote><h4 id="灵活的模式（Flexible-Schema）"><a href="#灵活的模式（Flexible-Schema）" class="headerlink" title="灵活的模式（Flexible Schema）"></a>灵活的模式（Flexible Schema）</h4><blockquote><p>从 3.0 版本开始，不推荐使用基于 Thrift API 的动态列创建的 API，并且 Cassandra 底层存储已经重新实现了，以更紧密地与 CQL 保持一致。 Cassandra 并没有完全限制动态扩展架构的能力，但它的工作方式却截然不同。 CQL 集合（比如 list、set、尤其是 map）提供了在无结构化的格式里面添加内容的能力，从而能扩展现有的模式。CQL 还提供了改变列的类型的能力，以支持 JSON 格式的文本的存储。</p></blockquote><h4 id="高性能-High-Performance"><a href="#高性能-High-Performance" class="headerlink" title="高性能(High Performance)"></a>高性能(High Performance)</h4><blockquote><p>设计之初就特别考虑了要充分利用多处理器和多核计算机的性能，并考虑在分布于多个数据中心的大量这类服务器上运行。它可以一致而且无缝地扩展到数百台机器，存储数 TB 的数据。Cassandra 已经显示出了高负载下的良好表现，在一个非常普通的工作站上，Cassandra 也可以提供非常高的写吞吐量。而如果你增加更多的服务器，你还可以继续保持 Cassandra 所有的特性而无需牺牲性能</p></blockquote><hr><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="大规模部署"><a href="#大规模部署" class="headerlink" title="大规模部署"></a>大规模部署</h4><blockquote><p>单节点不易发挥它的性能，多个节点部署cassandra才是最佳选择</p></blockquote><h4 id="写密集、统计和分析型工作"><a href="#写密集、统计和分析型工作" class="headerlink" title="写密集、统计和分析型工作"></a>写密集、统计和分析型工作</h4><blockquote><p>Cassandra 是为优异的写吞吐量而特别优化的。 早期用于存储用户状态更新、社交网络、建议/评价以及应用统计都是很好的应用场景。现又适用于窗口化的时间序列数据库，用于文档搜索的反向索引，以及分布式任务优先级队列。</p></blockquote><h4 id="地区分布"><a href="#地区分布" class="headerlink" title="地区分布"></a>地区分布</h4><blockquote><p>支持多地分布的数据存储，Cassandra 可以很容易配置成将数据分布到多个数据中心的存储方式。如果你有一个全球部署的应用，那么让数据贴近用户会获得不错的性能收益，Cassandra 正适合这种应用场合。</p></blockquote><h4 id="变化的应用"><a href="#变化的应用" class="headerlink" title="变化的应用"></a>变化的应用</h4><blockquote><p>正在“初创阶段”，业务会不断改进，Cassandra 这种灵活的模式的数据模型可能更适合你。这让你的数据库能更快地跟上业务改进的步伐。</p></blockquote><blockquote><p>参考地址：<a href="https://www.iteblog.com/archives/2530.html" target="_blank" rel="noopener">cassandra 简介</a></p></blockquote><hr><h4 id="Single-column-Primary-Key"><a href="#Single-column-Primary-Key" class="headerlink" title="Single column Primary Key"></a>Single column Primary Key</h4><blockquote><p>Primary Key 可以由一列或多列组成,用于从表中检索数据，如果 Primary Key 由一列组成，那么称为 Single column Primary Key&gt; 如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE iteblog_user (first_name text , last_name text, PRIMARY KEY (first_name)) ;</span><br></pre></td></tr></table></figure><blockquote><p>我们在检索数据的时候需要指定 Primary Key,不指定查询数据会抛以下异常：</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InvalidRequest: Error from server: code=2200 [Invalid query] </span><br><span class="line">message=&quot;Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. </span><br><span class="line">If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING&quot;</span><br></pre></td></tr></table></figure><h4 id="Composite-Primary-Key"><a href="#Composite-Primary-Key" class="headerlink" title="Composite Primary Key"></a>Composite Primary Key</h4><blockquote><p>如果 Primary Key 由多列组成，那么这种情况称为 Compound Primary Key 或 Composite Primary Key  如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE iteblog_user_composite (first_name text , last_name text, PRIMARY KEY (first_name, last_name)) ;</span><br></pre></td></tr></table></figure><blockquote><p>其中 first_name 称为 Partition key，last_name 称为 Clustering key（也可以称为 Clustering column）。在这种情况下，下面查询的前三条都是合法的，最后一条是非法的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cqlsh:iteblog_keyspace&gt; select * from iteblog_user_composite;</span><br><span class="line"> </span><br><span class="line">cqlsh:iteblog_keyspace&gt; select * from iteblog_user_composite where first_name = &apos;iteblog&apos;;</span><br><span class="line"> </span><br><span class="line">cqlsh:iteblog_keyspace&gt; select * from iteblog_user_composite where first_name = &apos;iteblog&apos; and last_name = &apos;hadoop&apos;;</span><br><span class="line"> </span><br><span class="line">//非法查询</span><br><span class="line">cqlsh:iteblog_keyspace&gt; select * from iteblog_user_composite where last_name = &apos;hadoop&apos;;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; Partition key 和 Clustering key(查询的时候不可以仅指定，需要和partition key 组合) 也可以由多个字段组成，如果 Partition key 由多个字段组成，称之为 Composite partition key：</span><br></pre></td></tr></table></figure><p>create table iteblog_multiple (<br>      k_part_one text,<br>      k_part_two int,<br>      k_clust_one text,<br>      k_clust_two int<br>      data text,<br>      PRIMARY KEY((k_part_one, k_part_two), k_clust_one, k_clust_two)<br>  );<br><code>`</code></p><blockquote><p>小知识：使用 Composite partition key 的一个原因<br>其实一个 Partition 对应的 Cell 个数在 Cassandra 里面是有限制的。理论上来说，一个 Partition 的 Cell 个数大约在20亿个（231）。所以采用了 Composite partition key，我们可以将数据分散到不同的 Partition，这样有利于将同一个 Partition 的 Cell 个数减少。</p></blockquote><h4 id="Partition-key-amp-Clustering-key-amp-Primary-Key-作用"><a href="#Partition-key-amp-Clustering-key-amp-Primary-Key-作用" class="headerlink" title="Partition key &amp; Clustering key &amp; Primary Key 作用"></a>Partition key &amp; Clustering key &amp; Primary Key 作用</h4><blockquote><p>Partition Key：将数据分散到集群的 node 上</p></blockquote><blockquote><p>Primary Key：在 Single column Primary Key 情况下作用和 Partition Key 一样；在 Composite Primary Key 情况下，组合 Partition key 字段决定数据的分发的节点；</p></blockquote><blockquote><p>Clustering Key：决定同一个分区内相同 Partition Key 数据的排序，默认为升序，我们可以在建表语句里面手动设置排序的方式（DESC 或 ASC）</p></blockquote><p>参考链接:<a href="https://www.iteblog.com/archives/2534.html" target="_blank" rel="noopener">Apache Cassandra Composite KeyPartition keyClustering key 介绍</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Apache Cassandra 是一个开源的、分布式、无中心、弹性可扩展、高可用、容错、一致性可调、面向
      
    
    </summary>
    
      <category term="cassandra" scheme="https://23yue23.github.io/categories/cassandra/"/>
    
    
      <category term="cassandra-学习篇" scheme="https://23yue23.github.io/tags/cassandra-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>代码库-邮件发送</title>
    <link href="https://23yue23.github.io/2019/05/06/%E4%BB%A3%E7%A0%81%E5%BA%93-%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    <id>https://23yue23.github.io/2019/05/06/代码库-邮件发送/</id>
    <published>2019-05-06T04:02:06.000Z</published>
    <updated>2019-09-25T02:39:38.093Z</updated>
    
    <content type="html"><![CDATA[<h4 id="scala-版本示例："><a href="#scala-版本示例：" class="headerlink" title="scala 版本示例："></a>scala 版本示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.LoggerFactory</span><br><span class="line"></span><br><span class="line">import javax.mail._</span><br><span class="line">import javax.mail.internet.InternetAddress</span><br><span class="line">import javax.mail.internet.MimeMessage</span><br><span class="line">import java.util.Properties</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">object Mail &#123;</span><br><span class="line">  val logger = LoggerFactory.getLogger(Mail.getClass)</span><br><span class="line">  val bodyHtml = &quot;&lt;!DOCTYPE html PUBLIC -//W3C//DTD HTML 4.01 Transitional//ENhttp://www.w3.org/TR/html4/loose.dtd&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=Content-Type content=text/html; charset=utf-8 pageEncoding=UTF-8&gt;&lt;/head&gt;&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;&quot;</span><br><span class="line">  val prop = new Properties()</span><br><span class="line">  prop.put(&quot;mail.smtp.host&quot;,&quot;smtp.exmail.qq.com&quot;)</span><br><span class="line">  prop.put(&quot;mail.smtp.auth&quot;,&quot;true&quot;)</span><br><span class="line">  prop.put(&quot;mail.smtp.connectiontimeout&quot;,&quot;10000&quot;)</span><br><span class="line">  prop.put(&quot;mail.smtp.timeout&quot;,&quot;20000&quot;)</span><br><span class="line"></span><br><span class="line">  def send(address: String, title: String, content: String) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      val addresses = address.split(&quot;,&quot;).map(new InternetAddress(_).asInstanceOf[Address])</span><br><span class="line">      val authenticator = new SMTPAuthenticator(&quot;username@qq.com&quot;, &quot;password&quot;)</span><br><span class="line">      val sendMailSession = Session.getDefaultInstance(prop, authenticator)</span><br><span class="line">      val newMessage = new MimeMessage(sendMailSession)</span><br><span class="line">      newMessage.setFrom(new InternetAddress(&quot;username@qq.com&quot;))</span><br><span class="line">      newMessage.setRecipients(Message.RecipientType.TO, addresses)</span><br><span class="line">      newMessage.setSubject(title)</span><br><span class="line">      val html = String.format(bodyHtml, content)</span><br><span class="line">      newMessage.setContent(html, &quot;text/html;charset=utf-8&quot;)</span><br><span class="line">      Transport.send(newMessage)</span><br><span class="line">      logger.info(&quot;send an email to address[&#123;&#125;] title[&#123;&#125;] content[&#123;&#125;]&quot;, addresses, title, content);</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case e: MessagingException =&gt; logger.info(&quot;error occur when mail&quot;, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class SMTPAuthenticator(username: String, password: String) extends Authenticator &#123;</span><br><span class="line">    override def getPasswordAuthentication: PasswordAuthentication = new PasswordAuthentication(username, password)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;scala-版本示例：&quot;&gt;&lt;a href=&quot;#scala-版本示例：&quot; class=&quot;headerlink&quot; title=&quot;scala 版本示例：&quot;&gt;&lt;/a&gt;scala 版本示例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="代码库" scheme="https://23yue23.github.io/categories/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="代码库-邮件发送" scheme="https://23yue23.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93-%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>spark-问题篇</title>
    <link href="https://23yue23.github.io/2019/04/29/spark-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    <id>https://23yue23.github.io/2019/04/29/spark-问题篇/</id>
    <published>2019-04-29T12:38:35.000Z</published>
    <updated>2019-09-25T02:39:26.405Z</updated>
    
    <content type="html"><![CDATA[<h5 id="org-apache-spark-SparkException-Could-not-find-CoarseGrainedScheduler"><a href="#org-apache-spark-SparkException-Could-not-find-CoarseGrainedScheduler" class="headerlink" title="org.apache.spark.SparkException: Could not find CoarseGrainedScheduler."></a>org.apache.spark.SparkException: Could not find CoarseGrainedScheduler.</h5><blockquote><ol><li>这个可能是一个资源问题，应该给任务分配更多的 cores 和Executors，并且分配更多的内存。并且需要给RDD分配更多的分区 </li><li>在配置资源中加入这句话也许能解决你的问题：<br> –conf spark.dynamicAllocation.enabled=false</li><li>经过一般调试，发现原来是因为spark任务生成task任务过少，而任务提交时所指定的Excutor 数过多导致，故调小 –num-executors 参数问题得以解决。</li></ol></blockquote><hr><p>##### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;org-apache-spark-SparkException-Could-not-find-CoarseGrainedScheduler&quot;&gt;&lt;a href=&quot;#org-apache-spark-SparkException-Could-not-find-Coar
      
    
    </summary>
    
      <category term="spark" scheme="https://23yue23.github.io/categories/spark/"/>
    
    
      <category term="spark-问题篇" scheme="https://23yue23.github.io/tags/spark-%E9%97%AE%E9%A2%98%E7%AF%87/"/>
    
  </entry>
  
</feed>
